# AI Context: Architecture

## Цель документа
Единый источник правды для ИИ-ассистентов по архитектуре `uran`, ориентированной на управляемый ручной процесс тестирования.

## Текущий стек
- Frontend: React + TypeScript + Vite (`frontend/`)
- Backend: Rust + Axum (`backend/`)
- Data: PostgreSQL 16 (источник схемы: `backend/migrations/`)
- Dev orchestration: `bin/start.sh` + `docker compose`

## Базовые доменные сущности
1. Test Library (библиотека тестов)
- Разделы/наборы, тест-кейсы, теги, обязательность, оценка времени, сложность.
- Обязательное версионирование тестов, чтобы исторические прогоны не менялись при редактировании кейса.

2. Runs (прогоны)
- Контекст выполнения: проект, asset (камера/прошивка/объект/стенд), инженер.
- Жизненный цикл: `draft -> in_progress -> done -> locked`.

3. Results (результаты внутри прогона)
- По каждому пункту: `ok / fail / na`, комментарий, вложения.

4. Audit Log (аудит)
- Кто/когда/что изменил: тесты, версии, состав прогона, результаты, роли, lock/unlock.

## Слои приложения
1. Presentation Layer (React)
- UI для библиотеки тестов, прогонов, результатов и аналитики.
- Работает только через API `/api/...`.
- LocalStorage не используется как primary storage для бизнес-данных.

2. API Layer (Axum)
- Авторизация, RBAC, CRUD библиотеки тестов.
- Управление прогонами, результатами, вложениями.
- Отдельные endpoint'ы для lock/unlock и аудита.
- Раздача frontend-статики через `fallback_service`.

3. Data Layer (PostgreSQL)
- Источник правды для доменных данных, аналитики и аудита.
- Контракты определяются миграциями.

## Роли и права
- `admin`: полный доступ, управление пользователями/правами.
- `lead`: управление библиотекой тестов, право lock/unlock прогонов.
- `engineer`: выполнение прогонов, заполнение результатов, добавление вложений.
- `viewer`: только чтение.

Критичное правило:
- После `locked` прогон не редактируется напрямую.
- Исправления только через регламентированную процедуру (новый прогон или controlled correction), которая всегда попадает в аудит.

## Потоки данных
1. Работа с библиотекой тестов
- Создание/редактирование кейса -> новая версия кейса.
- Старые версии остаются неизменными для исторических прогонов.

2. Создание прогона
- Инженер выбирает проект + asset + шаблон набора тестов.
- Система создаёт run и фиксирует конкретные `testcase_version` в `run_items`.

3. Заполнение результатов
- Для каждого `run_item`: статус, комментарий, вложения, причина FAIL (справочник + комментарий).

4. Завершение
- `done` фиксирует факт выполнения.
- `locked` фиксирует неизменяемый отчётный слепок.

5. Аудит
- Все значимые действия пишутся в `audit_log` с `before/after`.

## Админские панели
1. Главный дашборд
- Прогоны за период, покрытие, fail-rate, топ проблемных тестов, top engineers, long in_progress tail.

2. Библиотека тестов
- Дерево разделов, поиск, карточка кейса, история версий и изменений.

3. Прогоны
- Таблица прогонов + чеклист внутри прогона + вложения + итог и lock.

4. Производительность
- Завершённые прогоны, объём результатов, средняя длительность, возвраты/исправления, распределение FAIL/OK.

## Этапы внедрения
1. Библиотека тестов + версии
2. Прогоны + чеклист результатов
3. Админский дашборд
4. Аудит
5. Вложения
6. Аналитика причин FAIL + расширенные фильтры

## Правила архитектурных изменений
- Любое изменение API, модели данных, ролей или бизнес-процесса обновляет `docs/ai/` в том же коммите.
- При расхождении кода и документации приоритет у кода, но docs обновляются немедленно.
